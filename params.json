{"name":"Stfservice.apk","tagline":"Monitor and perform various actions on your Android device. Not meant for actual user devices.","body":"# STFService.apk\r\n\r\n**STFService.apk** is both an Android [Service](http://developer.android.com/guide/components/services.html) and a CLI-runnable \"agent\" application providing various services and event streams for [STF](https://github.com/openstf/stf). While it would usually make sense to separate these various services into their own components, we're trying to keep resource usage lower by bundling our services into a single package.\r\n\r\n## Features\r\n\r\n* [Protocol Buffers](https://github.com/google/protobuf) based socket interface\r\n* Monitoring\r\n    - Battery statistics\r\n    - Network connectivity\r\n    - Phone state\r\n    - Device rotation\r\n    - Airplane mode\r\n    - Installed browser packages\r\n* Actions\r\n    - List user accounts\r\n    - Remove user accounts\r\n    - Get list of installed browsers\r\n    - Get/set clipboard contents\r\n    - Get display information\r\n    - Get device IMEI number\r\n    - Get device phone number\r\n    - Get device ICCID number\r\n    - Get device network operator\r\n    - Get device network type\r\n    - Get/set device ringer mode\r\n    - Check whether an SD card is installed\r\n    - Enable/disable WIFI and query its status\r\n    - Unlock/relock [KeyGuard](http://developer.android.com/reference/android/app/KeyguardManager.html) (essentially unlocking a device)\r\n    - Acquire/release [WakeLock](http://developer.android.com/reference/android/os/PowerManager.WakeLock.html) (i.e. prevent a device from or allow it to sleep)\r\n    - Invoke key events (with meta key support)\r\n    - Set device rotation (optionally locking it)\r\n* Misc tasks\r\n    - Show a bright red screen with identifying information that wakes up and keeps the device on. Amazingly useful when you've got a whole bunch of devices you're connected to remotely, and you want to find the real, physical device.\r\n* More.\r\n\r\n## Requirements\r\n\r\n* [Android Studio](http://developer.android.com/tools/studio/index.html)\r\n* [ADB](http://developer.android.com/tools/help/adb.html) properly set up\r\n* `protoc` ([Protocol Buffers](https://github.com/google/protobuf) compiler) available in `/usr/local/bin/protoc`\r\n\r\nOn OS X, you can install `protoc` with:\r\n\r\n```bash\r\nbrew install protobuf\r\n```\r\n\r\n## Building\r\n\r\nBuild with Gradle:\r\n\r\n```bash\r\n./gradlew assembleDebug\r\n```\r\n\r\n## Running\r\n\r\nYou'll need to [build](#building) first.\r\n\r\nLike mentioned earlier, the service consists of two parts. The service is a normal Android Service, and is started with an activity. The agent part, however, requires permissions that are not available to 3rd party applications, but are available to ADB. So the agent is a \"normal\" Android CLI app. More on that later.\r\n\r\nAlso note that currently the debug keystore is fixed due to both convenience and laziness. Generate your own key if you feel like it.\r\n\r\n### Install the .apk\r\n\r\nFirst you need to install the APK. It contains both the service and the agent. This is pretty easy with Gradle:\r\n\r\n```bash\r\n./gradlew installDebug\r\n```\r\n\r\nNow you just need to start the two services.\r\n\r\n### Running the service\r\n\r\nThere is no launcher icon for the service as it is meant to interfere with the system and its UI as little as possible. You do get a foreground notification, though, as background services without it usually get killed quite often.\r\n\r\nStart the service via ADB as follows.\r\n\r\n```bash\r\nadb shell am startservice --user 0 \\\r\n    -a jp.co.cyberagent.stf.ACTION_START \\\r\n    -n jp.co.cyberagent.stf/.Service\r\n```\r\n\r\nIf your device complains about the `--user` option, just remove it and try again. This happens on older devices.\r\n\r\nYou should now have the service running on port 1100 on the device.\r\n\r\nNow we simply need to create a local forward so that we can eventually connect to the socket.\r\n\r\n```bash\r\nadb forward tcp:1100 tcp:1100\r\n```\r\n\r\nNow you can connect to the socket using the local port. You may have more than one connection open at once, but it usually doesn't make much sense as you will just unnecessarily consume the surprisingly scarce USB resources. With that in mind, let's connect.\r\n\r\n```bash\r\nnc localhost 1100\r\n```\r\n\r\nThis will give you binary output that will be explained in the [usage](#usage) section.\r\n\r\n### Running the agent\r\n\r\nRunning the agent is a bit more complicated.\r\n\r\nFirst, you must find out where the app got installed. We'll need the information very soon. Note that the path changed between every install, so you can't just use a static or cached value here.\r\n\r\nThe following command gets you the path.\r\n\r\n```bash\r\nAPK=$(adb shell pm path jp.co.cyberagent.stf | \\\r\n    tr -d '\\r' | awk -F: '{print $2}')\r\n```\r\n\r\nNow that you know the path, it's time to run the CLI app. Note that the app does not run in the background and will keep your shell occupied for as long as it runs.\r\n\r\n```bash\r\nadb shell export CLASSPATH=\"$APK\"\\; \\\r\n    exec app_process /system/bin jp.co.cyberagent.stf.Agent\r\n```\r\n\r\nBe very careful to note that this is a single command. The semicolon in the middle that would usually separate commands has been escaped.\r\n\r\nIf everything went well, the agent should have told you the port it started listening on. Currently it should be 1090.\r\n\r\nJust like before, now we simply need to create a local forward so that we can eventually connect to the socket.\r\n\r\n```bash\r\nadb forward tcp:1090 tcp:1090\r\n```\r\n\r\nOnce again, you may have more than one connection open at once, but it usually doesn't make much sense as you will just unnecessarily consume your precious USB bandwidth. Anyway, let's connect.\r\n\r\n```bash\r\nnc localhost 1090\r\n```\r\n\r\nThis, too, will give you binary output that will be explained in the [usage](#usage) section.\r\n\r\n## Usage\r\n\r\nIt is assumed that you now have an open connection to both the service and the agent. If not, follow the [instructions](#running) above.\r\n\r\nBoth sockets use **delimited** [Protocol Buffers](https://github.com/google/protobuf) as their format. This means that you can send different types of requests over the same connection. Each request must include an ID that gets returned in the response. You can then map the response to the request on your side. Use timeouts to check for lost requests, although that doesn't really happen as long as you send valid messages to the right socket (more on that later).\r\n\r\nYou will also receive monitoring events that simply get pushed as they occur without anyone requesting anything.\r\n\r\nAt this point it would be useful if you checked out our [wire.proto](proto/src/main/proto/wire.proto).\r\n\r\nWhile both sockets use the same format, neither is able to respond to all requests. You must know which socket to send your request to. The agent is currently only able to respond to the following requests:\r\n\r\n* `DO_KEYEVENT`\r\n* `DO_TYPE`\r\n* `DO_WAKE`\r\n* `SET_ROTATION`\r\n\r\nAll other requests must go to the service. Furthermore, while all requests to the service require an ID (which must be unique within a reasonable time interval) and then receive a response with that ID, the agent currently does not provide any responses, and the ID is therefore not required.\r\n\r\nThe requests themselves are heavily wrapped. Quite honestly it's probably a bit over-engineered in that sense, and a bit of a pain to use. But it works, and you're able to receive replies and monitoring events at any time in any order, without having to care about waiting for the previous request to complete.\r\n\r\nTake a look at the source to see the messages are sent and what you should expect. You can also take a look at [STF](https://github.com/openstf/stf) to see how the messages are being used in a [Node.js](https://nodejs.org/) application (although there are some abstractions in place).\r\n\r\n## Contributing\r\n\r\nSee [CONTRIBUTING.md](CONTRIBUTING.md).\r\n\r\n## License\r\n\r\nSee [LICENSE](LICENSE).\r\n\r\nCopyright Â© CyberAgent, Inc. All Rights Reserved.\r\n","google":"UA-64458786-1","note":"Don't delete this file! It's used internally to help with page regeneration."}